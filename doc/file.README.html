<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.18
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h2>The problem</h2>

<p>Given a dictionary and a M x N board where every cell has one character, find all possible words that are 3 letters or larger and that can be formed by a sequence of adjacent characters. Starting from a single cell, we can move to any of up to 8 adjacent characters (even diagonally), but a word should not reuse a letter from the same cell twice.</p>

<p>To solve this problem, you&#39;ll need to implement <code>Solver#solve</code> in `lib/solver.rb&#39;. </p>

<h3>Example</h3>

<p>Given the following board:</p>

<p><img src="https://github.com/ctrombley/word_game/raw/master/board.png" alt="board"></p>

<p>The words GEEKS and QUIZ can be found by traversing the cells in the board.  Others such as SEEK are also possible, but not highlighted in the diagram above. Your program should be able to find these words in the board and output them in a list before the program completes.</p>

<h3>Notes</h3>

<p>Two dependencies have been provided to instances of the <code>Solver</code> class, an instance of <code>Board</code> and an instance of <code>Dictionary</code>.  You will need a couple of methods provided by these dependencies to implement your solution:</p>

<ul>
<li><code>Board#value(m_value, n_value)</code> will return the letter stored at the given MxN coordinates in the board.</li>
<li><code>Dictionary#word?(word)</code> will return a boolean value indicating if the passed word is a valid English word.</li>
</ul>

<h3>Bonus</h3>

<p>Once the main problem has been solved, we can also consider the performance of the solution.  One area for consideration is the provided implementation for dictionary lookup - it is not very fast.  When calling <code>Dictionary#word?</code>, a <a href="https://www.studytonight.com/data-structures/linear-search-algorithm">linear search</a> is performed on an array.  Implement a more efficient method for performing dictionary lookups, and benchmark your results.</p>

<h2>Running the code</h2>

<pre class="code ruby"><code class="ruby">ruby boggle.rb --width 3 --height 3
</code></pre>

<p>Running the above code will generate a randomized board of specified width and height and then run the solution on that board.  The words found will be output to the command line.  Once the solver implementation is completed, this output should be a complete list of all the words found in the given board.</p>

<h2>Hints</h2>

<p><a href="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13">Depth first search</a> is an effective tool for solving the problem.  Once implemented, it can perform an exhaustive search of all of the possible combinations of letters.  It requires recursion, which is <a href="https://medium.freecodecamp.org/recursion-is-not-hard-858a48830d83">not as scary as it sounds</a>!</p>

<p>When making our dictionary lookup more performant, there are a few approaches that can be taken.   Implementing a more eficient search method such as <a href="https://www.studytonight.com/data-structures/binary-search-algorithm">binary search</a> would be a good first stab at the problem.  For even better performance, <a href="https://medium.com/basecs/trying-to-understand-tries-3ec6bede0014">tries</a> are a data structure that is worth looking into as a means of storing the internal representation of the dictionary. </p>
</div></div>

      <div id="footer">
  Generated on Mon Feb 11 11:05:08 2019 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.18 (ruby-2.3.4).
</div>

    </div>
  </body>
</html>